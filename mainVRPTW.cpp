// ===================================
// Main.cpp file generated by OptFrame
// Project Vehicle Routing Problem with Time Windows
// ===================================

#include <stdlib.h>
#include <math.h>

#include <iostream>

#include "./OptFrame/OptFrame.h"
#include "./OptFrame/Examples/VRPTW.h"

using namespace std;

#include "OptFrame/Util/printable.h"

void print_1(Solution<RepVRPTW> &s)
{
	RepVRPTW * rep = s.getRepresentation();
	for (int i = 0 ; i < rep->size() ; i++)
	{
		cout << rep->at(i) << endl;
	}
}

int main(int argc, char **argv)
{
	Timer timer;

	srand(time(NULL));

	/*   Scanner scanner(new File("instance.txt"));
   VRPTWProblemInstance* p = new VRPTWProblemInstance(scanner);
   PartialGreedyInitialSolutionVRPTW is(p);
   SolutionVRPTW* s = is.generateSolution();*/

	/* Solução Inicial */

	if (argc != 2)
	{
		cout << "Usage: mainVRPTW <instance_path>\n";
		exit(1);
	}

	Scanner scanner(new File(string(argv[1])));
	VRPTWProblemInstance input(scanner);
	CheapestInsertionInitialSolutionVRPTW isg(&input);
	//CheapestInsertionSeedInitialSolutionVRPTW isg(&input);
	Solution<RepVRPTW>* is = isg.generateSolution();
	is->print();

	SolutionVRPTW* s = is;

	VRPTWEvaluator eval(&input);
	eval.setDebug(false);
	eval.evaluate(s)->print();

	/**/
	VRPTWDistanceEvaluator evalDist(&input);
	evalDist.setDebug(false);
	VRPTWExcLoadEvaluator evalExcLoad(&input);
	evalExcLoad.setDebug(false);
	VRPTWDelayEvaluator evalDelay(&input);
	evalDelay.setDebug(false);

	GenericEvaluator<RepVRPTW,MemVRPTW> gev;
	//gev.setDebug(false);
	gev.add(&evalDist);
	gev.add(&evalDelay);
	gev.add(&evalExcLoad);
	/**/

	// local searches

	NSEnumShiftk shift1(1);
	NSEnumShiftk shift2(2);
//	NSEnumShiftk shift3(3);

	NSEnumSwapk swap11(1,1);
	NSEnumSwapk swap21(2,1);
	NSEnumSwapk swap22(2,2);

	MRNS<RepVRPTW,MemVRPTW> mrshift1(2,&shift1);

	PerturbationVRPTW pert(&shift1);

	HeuristicFactory<RepVRPTW,MemVRPTW> factory;

	factory.add_ev(&gev);
	factory.add_ev(&eval);
	factory.add_ev(&evalDist);
	factory.add_ev(&evalDelay);
	factory.add_ev(&evalExcLoad);
	factory.add_ns(&mrshift1);
	factory.add_ns(&shift1);
	factory.add_ns(&shift2);
//	factory.add_ns(&shift3);
	factory.add_ns(&swap11);
	factory.add_ns(&swap21);
	factory.add_ns(&swap22);
	factory.add_ilsl_pert(&pert);

	/*shift2.init(s);
	while (shift2.hasNext(s))
	{
		Move<RepVRPTW,MemVRPTW> * m = shift2.next(s);
		if (!m->canBeApplied(s->getRepresentation())) cout << "*";
		m->print();
	}*/

	pair<Heuristic<RepVRPTW>*, string> method;
	//method = factory.createHeuristic("Descida ev 0 ns 0");

	method = factory.createHeuristic("Descida gev [ ev 2 ev 3 ev 4 ] ns 0");

	s = method.first->search(s);
	eval.evaluate(s)->print();

	//method = factory.createHeuristic("SA ev 0 ns 0 0.99 2000 5232.5");
	//method = factory.createHeuristic("TS ev 0 ns 0 30 300");
	//method = factory.createHeuristic("MRD ev 0 ns 0 200");
	//method = factory.createHeuristic("VND ev 0 [ ns 0 ns 1 ns 2 ns 3 ns 4 ]");
	//method = factory.createHeuristic("ILSL ev 0 MRD ev 0 ns 0 500 ilsl_pert 0 10 15");
	//method = factory.createHeuristic("VNS ev 0 [ ns 0 ns 1 ] MRD ev 0 ns 0 200");
	//method = factory.createHeuristic("ILSL ev 0 RVND ev 0 [ ns 0 ns 1 ns 2 ns 3 ns 4 ] ilsl_pert 0 50 5");

	//method = factory.createHeuristic("ILSL ev 0 RVND gev [ ev 1 ev 3 ] [ ns 0 ns 1 ns 2 ns 3 ns 4 ] ilsl_pert 0 50 5");

	//s = method.first->search(s);
	eval.evaluate(s)->print();
	cout << *s->getRepresentation() << endl;

	return 0;
}
